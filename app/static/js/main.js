const state = {
  currentView: "credentials",
  apiPayloads: [],
  selectedApi: null,
  rules: [],
  tables: [],
  selectedTable: null,
  blueprints: null,
  blueprintDetails: {},
  selectedBlueprint: null,
  selectedBlueprintTable: null,
  blueprintDrafts: {},
};

function escapeHtml(value) {
  return String(value)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

const viewCopy = {
  credentials: {
    title: "Credentials",
    description: "OAuth credentials loaded from the demo environment.",
  },
  apis: {
    title: "API Catalogue",
    description:
      "Cached API responses grouped by entity type. Refresh to pull the latest payloads.",
  },
  rules: {
    title: "Transformation Rules",
    description:
      "Python snippets that map raw API payloads into queryable observability tables.",
  },
  blueprints: {
    title: "Blueprint Catalogue",
    description:
      "Registered entity blueprints with their declared tables, sample inputs, and rules.",
  },
  tables: {
    title: "Observability Tables",
    description: "SQLite tables generated by the latest ETL pipeline execution.",
  },
  views: {
    title: "Saved Views",
    description: "Combine tables to create reusable saved queries (coming soon).",
  },
  workflows: {
    title: "Workflows",
    description: "Orchestrate cross-table automations (work in progress).",
  },
  automations: {
    title: "Automations",
    description: "Trigger external systems based on saved queries (work in progress).",
  },
};

const navButtons = () => Array.from(document.querySelectorAll("#nav-pane .nav-item"));
const contentPane = () => document.getElementById("content-pane");
const detailPane = () => document.getElementById("detail-controls");
const detailTitle = () => document.getElementById("detail-title");

function setViewHeader(view) {
  const copy = viewCopy[view];
  document.getElementById("view-title").textContent = copy.title;
  document.getElementById("view-description").textContent = copy.description;
}

function setNavActive(view) {
  navButtons().forEach((btn) => {
    if (btn.dataset.view === view) {
      btn.classList.add("active");
    } else {
      btn.classList.remove("active");
    }
  });
}

async function renderCredentialsView() {
  setViewHeader("credentials");
  detailTitle().textContent = "Inspector";
  detailPane().innerHTML =
    "<p class=\"muted\">Credentials are read-only in this demo environment.</p>";

  const res = await fetch("/api/credentials");
  const data = await res.json();

  const rows = Object.entries(data)
    .map(
      ([key, value]) =>
        `<tr><th>${key}</th><td><code>${value}</code></td></tr>`
    )
    .join("");

  contentPane().innerHTML = `
    <div class="card">
      <h3>Demo OAuth Client</h3>
      <table>
        <tbody>${rows}</tbody>
      </table>
    </div>`;
}

async function ensureApiPayloadsLoaded() {
  if (state.apiPayloads.length) {
    return;
  }
  const res = await fetch("/api/apis");
  state.apiPayloads = await res.json();
}

async function renderApisView() {
  setViewHeader("apis");
  detailTitle().textContent = "JQ Explorer";
  detailPane().innerHTML = `
    <div class="right-pane-block">
      <h4>Run JQ Query</h4>
      <textarea id="jq-query" placeholder="e.g. .data.monitors[0]"></textarea>
      <div class="flex">
        <button class="primary" id="run-jq">Run</button>
        <button class="secondary" id="copy-jq-result">Copy Result</button>
      </div>
    </div>
    <div class="right-pane-block">
      <h4>Result</h4>
      <div class="result-box" id="jq-result">Select an API payload to query.</div>
    </div>`;

  await ensureApiPayloadsLoaded();
  const listItems = state.apiPayloads
    .map(
      (payload) => `
        <div class="list-item" data-id="${payload.id}">
          <div class="space-between">
            <strong>${payload.name}</strong>
            <span class="tag">${payload.category}</span>
          </div>
          <pre class="text-xs">${payload.preview}</pre>
          <button class="secondary text-sm" data-copy="${payload.id}">Copy Response</button>
        </div>`
    )
    .join("");

  contentPane().innerHTML = `<div class="list">${listItems}</div>`;

  contentPane()
    .querySelectorAll(".list-item")
    .forEach((el) => el.addEventListener("click", () => selectApiPayload(el.dataset.id, el)));

  contentPane()
    .querySelectorAll("button[data-copy]")
    .forEach((btn) => btn.addEventListener("click", handleCopyApi));

  document.getElementById("run-jq").addEventListener("click", () => executeJqQuery());
  document.getElementById("copy-jq-result").addEventListener("click", copyJqResult);

  if (state.selectedApi) {
    const el = contentPane().querySelector(`.list-item[data-id="${state.selectedApi}"]`);
    if (el) {
      el.classList.add("selected");
    }
  }
}

async function handleCopyApi(event) {
  event.stopPropagation();
  const id = event.currentTarget.dataset.copy;
  const res = await fetch(`/api/apis/${id}`);
  const data = await res.json();
  await navigator.clipboard.writeText(JSON.stringify(data, null, 2));
  showPipelineStatus("API response copied to clipboard.");
}

async function selectApiPayload(id, element) {
  state.selectedApi = id;
  contentPane()
    .querySelectorAll(".list-item")
    .forEach((el) => el.classList.toggle("selected", el === element));

  const res = await fetch(`/api/apis/${id}`);
  const data = await res.json();
  const pretty = JSON.stringify(data, null, 2);

  element.querySelector("pre").textContent = pretty.slice(0, 240) + (pretty.length > 240 ? "…" : "");

  const detail = document.getElementById("jq-result");
  detail.textContent = pretty;
}

async function executeJqQuery() {
  if (!state.selectedApi) {
    showPipelineStatus("Select an API payload first", true);
    return;
  }

  const query = document.getElementById("jq-query").value.trim();
  if (!query) {
    showPipelineStatus("Enter a JQ query", true);
    return;
  }

  const res = await fetch(`/api/apis/${state.selectedApi}/jq`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ query }),
  });

  const payload = await res.json();
  const detail = document.getElementById("jq-result");
  if (!res.ok) {
    detail.textContent = `Error: ${payload.error}`;
  } else {
    detail.textContent = JSON.stringify(payload.result, null, 2);
  }
}

async function copyJqResult() {
  const detail = document.getElementById("jq-result");
  if (!detail || !detail.textContent.trim()) {
    return;
  }
  await navigator.clipboard.writeText(detail.textContent);
  showPipelineStatus("JQ result copied to clipboard.");
}

async function ensureRulesLoaded() {
  if (state.rules.length) {
    return;
  }
  const res = await fetch("/api/rules");
  state.rules = await res.json();
}

async function renderRulesView() {
  setViewHeader("rules");
  detailTitle().textContent = "Rule Designer";

  detailPane().innerHTML = `
    <div class="right-pane-block">
      <h4>Preview Transformation</h4>
      <textarea id="rule-preview-content" placeholder="Paste a rule snippet or edit an existing rule."></textarea>
      <input type="text" id="rule-preview-input" placeholder="Relative input path (e.g. sample_inputs/entities/api_current_status.json)" />
      <div class="flex">
        <button class="primary" id="run-rule-preview">Preview</button>
        <button class="secondary" id="save-rule">Save as New Rule</button>
      </div>
    </div>
    <div class="right-pane-block">
      <h4>Preview Result</h4>
      <div class="result-box" id="rule-preview-result">Select a rule to populate the editor.</div>
    </div>`;

  document
    .getElementById("run-rule-preview")
    .addEventListener("click", () => previewRuleTransformation());
  document.getElementById("save-rule").addEventListener("click", () => saveCustomRule());

  await ensureRulesLoaded();

  const cards = state.rules
    .map(
      (rule) => `
        <div class="card" data-rule="${rule.name}">
          <div class="space-between">
            <div>
              <h3>${rule.title || rule.name}</h3>
              <p class="muted text-sm">${rule.description || ""}</p>
            </div>
            <span class="tag">${rule.table_type || "custom"}</span>
          </div>
          <pre class="text-xs">${rule.content.slice(0, 400)}${rule.content.length > 400 ? "…" : ""}</pre>
          <div class="flex">
            <button class="primary" data-action="preview" data-rule="${rule.name}">Preview</button>
            <button class="secondary" data-action="edit" data-rule="${rule.name}">Load into Editor</button>
          </div>
        </div>`
    )
    .join("");

  contentPane().innerHTML = cards || `<p class="muted">No rules available.</p>`;

  contentPane()
    .querySelectorAll("button[data-action='preview']")
    .forEach((btn) => btn.addEventListener("click", () => previewRule(btn.dataset.rule)));

  contentPane()
    .querySelectorAll("button[data-action='edit']")
    .forEach((btn) => btn.addEventListener("click", () => loadRuleIntoEditor(btn.dataset.rule)));
}

function loadRuleIntoEditor(ruleName) {
  const rule = state.rules.find((r) => r.name === ruleName);
  if (!rule) {
    return;
  }
  document.getElementById("rule-preview-content").value = rule.content;
  document.getElementById("rule-preview-input").value = rule.input || "";
  detailTitle().textContent = `Rule Designer – ${rule.title || rule.name}`;
}

async function previewRule(ruleName) {
  loadRuleIntoEditor(ruleName);
  await previewRuleTransformation(ruleName);
}

async function previewRuleTransformation(ruleName = null) {
  const content = document.getElementById("rule-preview-content").value;
  const inputPath = document.getElementById("rule-preview-input").value;
  const body = { rule_content: content, input_path: inputPath };
  if (ruleName) {
    body.rule_name = ruleName;
  }

  const res = await fetch("/api/rules/preview", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const payload = await res.json();

  const resultBox = document.getElementById("rule-preview-result");
  if (!res.ok) {
    resultBox.textContent = `Error: ${payload.error}`;
  } else {
    resultBox.textContent = JSON.stringify(payload, null, 2);
  }
}

async function saveCustomRule() {
  const name = prompt("New rule name (alphanumeric & underscores)");
  if (!name) {
    return;
  }
  const content = document.getElementById("rule-preview-content").value;
  if (!content.trim()) {
    showPipelineStatus("Rule content is empty", true);
    return;
  }

  const res = await fetch("/api/rules", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ name, content }),
  });
  const payload = await res.json();
  if (res.ok) {
    state.rules = [];
    await ensureRulesLoaded();
    renderRulesView();
    showPipelineStatus("Rule saved.");
  } else {
    showPipelineStatus(payload.error || "Unable to save rule", true);
  }
}

async function ensureTablesLoaded() {
  const res = await fetch("/api/tables");
  state.tables = await res.json();
}

async function renderTablesView() {
  setViewHeader("tables");
  detailTitle().textContent = "SQL Query";
  detailPane().innerHTML = `
    <div class="right-pane-block">
      <h4>Run SQLite Query</h4>
      <textarea id="sql-query" placeholder="SELECT * FROM entities LIMIT 10;"></textarea>
      <button class="primary" id="run-sql">Execute</button>
    </div>
    <div class="right-pane-block">
      <h4>Result</h4>
      <div class="result-box" id="sql-result">Choose a table to populate the query editor.</div>
    </div>`;

  document.getElementById("run-sql").addEventListener("click", () => executeSqlQuery());

  await ensureTablesLoaded();

  const cards = state.tables
    .map(
      (table) => `
        <div class="card" data-table="${table.table_name}">
          <div class="space-between">
            <h3>${table.table_name}</h3>
            <span class="tag">${table.rowcount} rows</span>
          </div>
          <p class="muted text-sm">Columns: ${table.columns.join(", ")}</p>
          <pre class="text-xs">${JSON.stringify(table.preview.slice(0, 3), null, 2)}</pre>
          <button class="secondary" data-table="${table.table_name}">View Details</button>
        </div>`
    )
    .join("");

  contentPane().innerHTML = cards || `<p class="muted">Run the pipeline to generate tables.</p>`;

  contentPane()
    .querySelectorAll("button[data-table]")
    .forEach((btn) =>
      btn.addEventListener("click", () => selectTable(btn.dataset.table))
    );
}

function selectTable(name) {
  state.selectedTable = name;
  const textarea = document.getElementById("sql-query");
  textarea.value = `SELECT * FROM ${name} LIMIT 20;`;
  showPipelineStatus(`Ready to query ${name}`);
}

async function executeSqlQuery() {
  const query = document.getElementById("sql-query").value;
  if (!query.trim()) {
    showPipelineStatus("Enter a SQL query", true);
    return;
  }
  const res = await fetch("/api/tables/query", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ query }),
  });
  const payload = await res.json();
  const resultBox = document.getElementById("sql-result");
  if (!res.ok) {
    resultBox.textContent = `Error: ${payload.error}`;
  } else {
    resultBox.textContent = JSON.stringify(payload, null, 2);
  }
}

async function ensureBlueprintsLoaded() {
  if (state.blueprints !== null) {
    return;
  }
  try {
    const res = await fetch("/api/blueprints");
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}`);
    }
    const payload = await res.json();
    state.blueprints = Array.isArray(payload) ? payload : [];
  } catch (err) {
    state.blueprints = [];
    showPipelineStatus(`Unable to load blueprints: ${err.message}`, true);
  }
}

function blueprintCardMarkup(blueprint) {
  const tableBadges = (blueprint.sources || [])
    .slice(0, 6)
    .map(
      (source) =>
        `<li><span class="tag">${escapeHtml(
          source.table_type || source.pillar || ""
        )}</span>${escapeHtml(source.table_name || "")}</li>`
    )
    .join("");
  const overflowCount = Math.max((blueprint.sources || []).length - 6, 0);
  const extraBadge =
    overflowCount > 0
      ? `<li><span class="tag">+${overflowCount}</span>more tables</li>`
      : "";

  return `
    <div class="card blueprint-card" data-blueprint="${escapeHtml(
      blueprint.entity_type
    )}">
      <div class="space-between">
        <div>
          <h3>${escapeHtml(blueprint.entity_type)}</h3>
          <p class="muted text-xs">${escapeHtml(blueprint.path || "")}</p>
        </div>
        <span class="tag">${(blueprint.sources || []).length} tables</span>
      </div>
      <ul class="chip-list">${tableBadges}${extraBadge}</ul>
      <p class="muted text-xs">Click to inspect table schemas and YAML.</p>
    </div>`;
}

async function renderBlueprintsView() {
  setViewHeader("blueprints");
  await ensureBlueprintsLoaded();

  const list = state.blueprints || [];
  if (!list.length) {
    contentPane().innerHTML = `<p class="muted">No blueprints registered yet.</p>`;
  } else {
    const cards = list.map(blueprintCardMarkup).join("");
    contentPane().innerHTML = `<div class="card-column">${cards}</div>`;
  }

  contentPane()
    .querySelectorAll(".card[data-blueprint]")
    .forEach((card) => {
      card.addEventListener("click", () => selectBlueprint(card.dataset.blueprint, card));
      card.classList.toggle(
        "selected",
        card.dataset.blueprint === state.selectedBlueprint
      );
    });

  renderBlueprintDetailPane();
}

async function selectBlueprint(entityType, element) {
  if (!entityType) {
    return;
  }
  state.selectedBlueprint = entityType;
  state.selectedBlueprintTable = null;

  contentPane()
    .querySelectorAll(".card[data-blueprint]")
    .forEach((card) => card.classList.toggle("selected", card === element));

  if (!state.blueprintDetails[entityType]) {
    detailTitle().textContent = `Blueprint · ${entityType}`;
    detailPane().innerHTML = `<p class="muted">Loading blueprint definition…</p>`;
    try {
      const res = await fetch(`/api/blueprints/${encodeURIComponent(entityType)}`);
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}`);
      }
      state.blueprintDetails[entityType] = await res.json();
    } catch (err) {
      showPipelineStatus(`Unable to load blueprint: ${err.message}`, true);
      return;
    }
  }

  renderBlueprintDetailPane();
}

function renderBlueprintDetailValue(value, format = "text") {
  if (value === undefined || value === null) {
    return '<span class="muted">—</span>';
  }

  if (Array.isArray(value)) {
    if (!value.length) {
      return '<span class="muted">—</span>';
    }
    if (format === "chips" || format === "list") {
      const items = value
        .map((item) => `<li>${escapeHtml(item)}</li>`)
        .join("");
      return `<ul class="chip-list">${items}</ul>`;
    }
    return escapeHtml(value.join(", "));
  }

  if (typeof value === "object") {
    if (!Object.keys(value).length) {
      return '<span class="muted">—</span>';
    }
    return `<pre class="text-xs">${escapeHtml(JSON.stringify(value, null, 2))}</pre>`;
  }

  if (format === "code") {
    return `<pre class="text-xs">${escapeHtml(value)}</pre>`;
  }

  const trimmed = String(value).trim();
  if (!trimmed) {
    return '<span class="muted">—</span>';
  }
  return escapeHtml(trimmed);
}

function renderBlueprintDetailPane() {
  if (!state.selectedBlueprint) {
    detailTitle().textContent = "Blueprint Explorer";
    detailPane().innerHTML =
      '<p class="muted">Select a blueprint to inspect its tables and YAML definition.</p>';
    return;
  }

  const details = state.blueprintDetails[state.selectedBlueprint];
  if (!details) {
    detailTitle().textContent = `Blueprint · ${state.selectedBlueprint}`;
    detailPane().innerHTML = '<p class="muted">Loading blueprint definition…</p>';
    return;
  }

  detailTitle().textContent = `Blueprint · ${details.entity_type}`;

  if (!state.selectedBlueprintTable && details.tables.length) {
    state.selectedBlueprintTable = details.tables[0].id;
  }

  const tableOptions = details.tables
    .map(
      (table) =>
        `<option value="${escapeHtml(table.id)}" ${
          table.id === state.selectedBlueprintTable ? "selected" : ""
        }>${escapeHtml(table.table_type || table.type || "")}
        · ${escapeHtml(table.table_name || table.table || "")}</option>`
    )
    .join("");

  const activeTable = details.tables.find(
    (table) => table.id === state.selectedBlueprintTable
  );

  let tableRows =
    '<tr><td colspan="2" class="muted">Select a table to view its configuration.</td></tr>';

  if (activeTable) {
    const parameterSummary = Object.entries(
      (activeTable.source && activeTable.source.parameters) || {}
    ).map(([name, spec]) => {
      if (spec && typeof spec === "object") {
        const parts = [];
        if (spec.source) parts.push(`source=${spec.source}`);
        if (spec.value !== undefined)
          parts.push(`value=${String(spec.value)}`);
        if (spec.default !== undefined)
          parts.push(`default=${String(spec.default)}`);
        if (spec.required) parts.push("required");
        if (spec.description) parts.push(String(spec.description));
        const detail = parts.length ? parts.join(" · ") : "—";
        return `${name}: ${detail}`;
      }
      return `${name}: ${String(spec)}`;
    });

    const extractorSummary = (activeTable.extractors || []).map((extractor) =>
      extractor.output_row_name
        ? `${extractor.name} → ${extractor.output_row_name}`
        : extractor.name
    );

    const samplePath =
      (activeTable.sample && activeTable.sample.path) || activeTable.sample_input;

    const rows = [
      { label: "Pillar", value: activeTable.pillar },
      { label: "Table type", value: activeTable.table_type || activeTable.type },
      { label: "Destination table", value: activeTable.table_name || activeTable.table },
      { label: "Description", value: activeTable.description },
      { label: "Upsert keys", value: activeTable.upsert_keys, format: "chips" },
      {
        label: "Extractors",
        value: extractorSummary,
        format: "list",
      },
      {
        label: "Transform rules",
        value: activeTable.transformations,
        format: "list",
      },
      { label: "Sample input", value: samplePath },
      {
        label: "Sample format",
        value: activeTable.sample && activeTable.sample.format,
      },
      {
        label: "Source kind",
        value: activeTable.source && activeTable.source.kind,
      },
      {
        label: "Endpoint",
        value: activeTable.source && activeTable.source.endpoint,
        format: "code",
      },
      {
        label: "HTTP method",
        value: activeTable.source && activeTable.source.method,
      },
      {
        label: "Source config",
        value: activeTable.source && activeTable.source.config,
      },
      {
        label: "Source parameters",
        value: parameterSummary,
        format: "list",
      },
      { label: "Inputs", value: activeTable.inputs },
      { label: "Metadata", value: activeTable.metadata },
    ];

    tableRows = rows
      .map(
        (row) =>
          `<tr><th>${escapeHtml(row.label)}</th><td>${renderBlueprintDetailValue(
            row.value,
            row.format
          )}</td></tr>`
      )
      .join("");
  }

  detailPane().innerHTML = `
    <div class="right-pane-block">
      <h4>Table Configuration</h4>
      <select id="blueprint-table-select">
        ${tableOptions}
      </select>
      <table class="kv-table">
        <tbody>${tableRows}</tbody>
      </table>
    </div>
    <div class="right-pane-block">
      <h4>Blueprint YAML</h4>
      <textarea id="blueprint-editor"></textarea>
      <div class="flex">
        <button class="secondary" id="copy-blueprint-yaml">Copy YAML</button>
        <button class="secondary" id="reset-blueprint-yaml">Reset</button>
      </div>
      <p class="muted text-xs">Edits stay in the browser for preview only.</p>
    </div>
  `;

  const select = document.getElementById("blueprint-table-select");
  if (select) {
    select.addEventListener("change", handleBlueprintTableChange);
  }

  const editor = document.getElementById("blueprint-editor");
  if (editor) {
    const draft = state.blueprintDrafts[state.selectedBlueprint];
    editor.value = draft !== undefined ? draft : details.yaml;
    editor.addEventListener("input", () => {
      state.blueprintDrafts[state.selectedBlueprint] = editor.value;
    });
  }

  const copyButton = document.getElementById("copy-blueprint-yaml");
  if (copyButton && editor) {
    copyButton.addEventListener("click", async () => {
      await copyBlueprintYaml(editor.value);
    });
  }

  const resetButton = document.getElementById("reset-blueprint-yaml");
  if (resetButton && editor) {
    resetButton.addEventListener("click", () => {
      editor.value = details.yaml;
      state.blueprintDrafts[state.selectedBlueprint] = details.yaml;
      showPipelineStatus("Blueprint YAML reset to original.");
    });
  }
}

function handleBlueprintTableChange(event) {
  state.selectedBlueprintTable = event.target.value;
  renderBlueprintDetailPane();
}

async function copyBlueprintYaml(value) {
  if (!value) {
    showPipelineStatus("Blueprint YAML is empty", true);
    return;
  }
  try {
    await navigator.clipboard.writeText(value);
    showPipelineStatus("Blueprint YAML copied to clipboard.");
  } catch (err) {
    showPipelineStatus(`Unable to copy YAML: ${err.message}`, true);
  }
}

async function renderPlaceholderView(key) {
  setViewHeader(key);
  contentPane().innerHTML = `<div class="card"><p class="muted">${viewCopy[key].description}</p></div>`;
  detailTitle().textContent = "Inspector";
  detailPane().innerHTML = `<p class="muted">This module will be implemented in the next project phase.</p>`;
}

function showPipelineStatus(message, isError = false) {
  const el = document.getElementById("pipeline-status");
  el.textContent = message;
  el.classList.toggle("text-error", isError);
  el.classList.toggle("text-success", !isError);
}

async function runPipeline() {
  showPipelineStatus("Running ETL pipeline…");
  const res = await fetch("/api/pipeline/run", { method: "POST" });
  if (res.ok) {
    state.tables = [];
    await ensureTablesLoaded();
    showPipelineStatus("Pipeline executed successfully.");
    if (state.currentView === "tables") {
      renderTablesView();
    }
  } else {
    showPipelineStatus("Pipeline execution failed", true);
  }
}

async function handleNavigation(event) {
  const view = event.currentTarget.dataset.view;
  if (!view || state.currentView === view) {
    return;
  }
  state.currentView = view;
  setNavActive(view);
  switch (view) {
    case "credentials":
      await renderCredentialsView();
      break;
    case "apis":
      await renderApisView();
      break;
    case "rules":
      await renderRulesView();
      break;
    case "blueprints":
      await renderBlueprintsView();
      break;
    case "tables":
      await renderTablesView();
      break;
    case "views":
    case "workflows":
    case "automations":
      await renderPlaceholderView(view);
      break;
    default:
      break;
  }
}

function bootstrap() {
  navButtons().forEach((btn) => btn.addEventListener("click", handleNavigation));
  document.getElementById("run-pipeline").addEventListener("click", runPipeline);
  renderCredentialsView();
}

document.addEventListener("DOMContentLoaded", bootstrap);
