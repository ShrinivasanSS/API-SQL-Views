const state = {
  currentView: "credentials",
  apiPayloads: [],
  selectedApi: null,
  rules: [],
  tables: [],
  selectedTable: null,
};

const viewCopy = {
  credentials: {
    title: "Credentials",
    description: "OAuth credentials loaded from the demo environment.",
  },
  apis: {
    title: "API Catalogue",
    description:
      "Cached API responses grouped by entity type. Refresh to pull the latest payloads.",
  },
  rules: {
    title: "Transformation Rules",
    description:
      "Python snippets that map raw API payloads into queryable observability tables.",
  },
  tables: {
    title: "Observability Tables",
    description: "SQLite tables generated by the latest ETL pipeline execution.",
  },
  views: {
    title: "Saved Views",
    description: "Combine tables to create reusable saved queries (coming soon).",
  },
  workflows: {
    title: "Workflows",
    description: "Orchestrate cross-table automations (work in progress).",
  },
  automations: {
    title: "Automations",
    description: "Trigger external systems based on saved queries (work in progress).",
  },
};

const navButtons = () => Array.from(document.querySelectorAll("#nav-pane .nav-item"));
const contentPane = () => document.getElementById("content-pane");
const detailPane = () => document.getElementById("detail-controls");
const detailTitle = () => document.getElementById("detail-title");

function setViewHeader(view) {
  const copy = viewCopy[view];
  document.getElementById("view-title").textContent = copy.title;
  document.getElementById("view-description").textContent = copy.description;
}

function setNavActive(view) {
  navButtons().forEach((btn) => {
    if (btn.dataset.view === view) {
      btn.classList.add("active");
    } else {
      btn.classList.remove("active");
    }
  });
}

async function renderCredentialsView() {
  setViewHeader("credentials");
  detailTitle().textContent = "Inspector";
  detailPane().innerHTML =
    "<p class=\"muted\">Credentials are read-only in this demo environment.</p>";

  const res = await fetch("/api/credentials");
  const data = await res.json();

  const rows = Object.entries(data)
    .map(
      ([key, value]) =>
        `<tr><th>${key}</th><td><code>${value}</code></td></tr>`
    )
    .join("");

  contentPane().innerHTML = `
    <div class="card">
      <h3>Demo OAuth Client</h3>
      <table>
        <tbody>${rows}</tbody>
      </table>
    </div>`;
}

async function ensureApiPayloadsLoaded() {
  if (state.apiPayloads.length) {
    return;
  }
  const res = await fetch("/api/apis");
  state.apiPayloads = await res.json();
}

async function renderApisView() {
  setViewHeader("apis");
  detailTitle().textContent = "JQ Explorer";
  detailPane().innerHTML = `
    <div class="right-pane-block">
      <h4>Run JQ Query</h4>
      <textarea id="jq-query" placeholder="e.g. .data.monitors[0]"></textarea>
      <div class="flex">
        <button class="primary" id="run-jq">Run</button>
        <button class="secondary" id="copy-jq-result">Copy Result</button>
      </div>
    </div>
    <div class="right-pane-block">
      <h4>Result</h4>
      <div class="result-box" id="jq-result">Select an API payload to query.</div>
    </div>`;

  await ensureApiPayloadsLoaded();
  const listItems = state.apiPayloads
    .map(
      (payload) => `
        <div class="list-item" data-id="${payload.id}">
          <div class="space-between">
            <strong>${payload.name}</strong>
            <span class="tag">${payload.category}</span>
          </div>
          <pre class="text-xs">${payload.preview}</pre>
          <button class="secondary text-sm" data-copy="${payload.id}">Copy Response</button>
        </div>`
    )
    .join("");

  contentPane().innerHTML = `<div class="list">${listItems}</div>`;

  contentPane()
    .querySelectorAll(".list-item")
    .forEach((el) => el.addEventListener("click", () => selectApiPayload(el.dataset.id, el)));

  contentPane()
    .querySelectorAll("button[data-copy]")
    .forEach((btn) => btn.addEventListener("click", handleCopyApi));

  document.getElementById("run-jq").addEventListener("click", () => executeJqQuery());
  document.getElementById("copy-jq-result").addEventListener("click", copyJqResult);

  if (state.selectedApi) {
    const el = contentPane().querySelector(`.list-item[data-id="${state.selectedApi}"]`);
    if (el) {
      el.classList.add("selected");
    }
  }
}

async function handleCopyApi(event) {
  event.stopPropagation();
  const id = event.currentTarget.dataset.copy;
  const res = await fetch(`/api/apis/${id}`);
  const data = await res.json();
  await navigator.clipboard.writeText(JSON.stringify(data, null, 2));
  showPipelineStatus("API response copied to clipboard.");
}

async function selectApiPayload(id, element) {
  state.selectedApi = id;
  contentPane()
    .querySelectorAll(".list-item")
    .forEach((el) => el.classList.toggle("selected", el === element));

  const res = await fetch(`/api/apis/${id}`);
  const data = await res.json();
  const pretty = JSON.stringify(data, null, 2);

  element.querySelector("pre").textContent = pretty.slice(0, 240) + (pretty.length > 240 ? "…" : "");

  const detail = document.getElementById("jq-result");
  detail.textContent = pretty;
}

async function executeJqQuery() {
  if (!state.selectedApi) {
    showPipelineStatus("Select an API payload first", true);
    return;
  }

  const query = document.getElementById("jq-query").value.trim();
  if (!query) {
    showPipelineStatus("Enter a JQ query", true);
    return;
  }

  const res = await fetch(`/api/apis/${state.selectedApi}/jq`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ query }),
  });

  const payload = await res.json();
  const detail = document.getElementById("jq-result");
  if (!res.ok) {
    detail.textContent = `Error: ${payload.error}`;
  } else {
    detail.textContent = JSON.stringify(payload.result, null, 2);
  }
}

async function copyJqResult() {
  const detail = document.getElementById("jq-result");
  if (!detail || !detail.textContent.trim()) {
    return;
  }
  await navigator.clipboard.writeText(detail.textContent);
  showPipelineStatus("JQ result copied to clipboard.");
}

async function ensureRulesLoaded() {
  if (state.rules.length) {
    return;
  }
  const res = await fetch("/api/rules");
  state.rules = await res.json();
}

async function renderRulesView() {
  setViewHeader("rules");
  detailTitle().textContent = "Rule Designer";

  detailPane().innerHTML = `
    <div class="right-pane-block">
      <h4>Preview Transformation</h4>
      <textarea id="rule-preview-content" placeholder="Paste a rule snippet or edit an existing rule."></textarea>
      <input type="text" id="rule-preview-input" placeholder="Relative input path (e.g. sample_inputs/entities/api_current_status.json)" />
      <div class="flex">
        <button class="primary" id="run-rule-preview">Preview</button>
        <button class="secondary" id="save-rule">Save as New Rule</button>
      </div>
    </div>
    <div class="right-pane-block">
      <h4>Preview Result</h4>
      <div class="result-box" id="rule-preview-result">Select a rule to populate the editor.</div>
    </div>`;

  document
    .getElementById("run-rule-preview")
    .addEventListener("click", () => previewRuleTransformation());
  document.getElementById("save-rule").addEventListener("click", () => saveCustomRule());

  await ensureRulesLoaded();

  const cards = state.rules
    .map(
      (rule) => `
        <div class="card" data-rule="${rule.name}">
          <div class="space-between">
            <div>
              <h3>${rule.title || rule.name}</h3>
              <p class="muted text-sm">${rule.description || ""}</p>
            </div>
            <span class="tag">${rule.table_type || "custom"}</span>
          </div>
          <pre class="text-xs">${rule.content.slice(0, 400)}${rule.content.length > 400 ? "…" : ""}</pre>
          <div class="flex">
            <button class="primary" data-action="preview" data-rule="${rule.name}">Preview</button>
            <button class="secondary" data-action="edit" data-rule="${rule.name}">Load into Editor</button>
          </div>
        </div>`
    )
    .join("");

  contentPane().innerHTML = cards || `<p class="muted">No rules available.</p>`;

  contentPane()
    .querySelectorAll("button[data-action='preview']")
    .forEach((btn) => btn.addEventListener("click", () => previewRule(btn.dataset.rule)));

  contentPane()
    .querySelectorAll("button[data-action='edit']")
    .forEach((btn) => btn.addEventListener("click", () => loadRuleIntoEditor(btn.dataset.rule)));
}

function loadRuleIntoEditor(ruleName) {
  const rule = state.rules.find((r) => r.name === ruleName);
  if (!rule) {
    return;
  }
  document.getElementById("rule-preview-content").value = rule.content;
  document.getElementById("rule-preview-input").value = rule.input || "";
  detailTitle().textContent = `Rule Designer – ${rule.title || rule.name}`;
}

async function previewRule(ruleName) {
  loadRuleIntoEditor(ruleName);
  await previewRuleTransformation(ruleName);
}

async function previewRuleTransformation(ruleName = null) {
  const content = document.getElementById("rule-preview-content").value;
  const inputPath = document.getElementById("rule-preview-input").value;
  const body = { rule_content: content, input_path: inputPath };
  if (ruleName) {
    body.rule_name = ruleName;
  }

  const res = await fetch("/api/rules/preview", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const payload = await res.json();

  const resultBox = document.getElementById("rule-preview-result");
  if (!res.ok) {
    resultBox.textContent = `Error: ${payload.error}`;
  } else {
    resultBox.textContent = JSON.stringify(payload, null, 2);
  }
}

async function saveCustomRule() {
  const name = prompt("New rule name (alphanumeric & underscores)");
  if (!name) {
    return;
  }
  const content = document.getElementById("rule-preview-content").value;
  if (!content.trim()) {
    showPipelineStatus("Rule content is empty", true);
    return;
  }

  const res = await fetch("/api/rules", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ name, content }),
  });
  const payload = await res.json();
  if (res.ok) {
    state.rules = [];
    await ensureRulesLoaded();
    renderRulesView();
    showPipelineStatus("Rule saved.");
  } else {
    showPipelineStatus(payload.error || "Unable to save rule", true);
  }
}

async function ensureTablesLoaded() {
  const res = await fetch("/api/tables");
  state.tables = await res.json();
}

async function renderTablesView() {
  setViewHeader("tables");
  detailTitle().textContent = "SQL Query";
  detailPane().innerHTML = `
    <div class="right-pane-block">
      <h4>Run SQLite Query</h4>
      <textarea id="sql-query" placeholder="SELECT * FROM entities LIMIT 10;"></textarea>
      <button class="primary" id="run-sql">Execute</button>
    </div>
    <div class="right-pane-block">
      <h4>Result</h4>
      <div class="result-box" id="sql-result">Choose a table to populate the query editor.</div>
    </div>`;

  document.getElementById("run-sql").addEventListener("click", () => executeSqlQuery());

  await ensureTablesLoaded();

  const cards = state.tables
    .map(
      (table) => `
        <div class="card" data-table="${table.table_name}">
          <div class="space-between">
            <h3>${table.table_name}</h3>
            <span class="tag">${table.rowcount} rows</span>
          </div>
          <p class="muted text-sm">Columns: ${table.columns.join(", ")}</p>
          <pre class="text-xs">${JSON.stringify(table.preview.slice(0, 3), null, 2)}</pre>
          <button class="secondary" data-table="${table.table_name}">View Details</button>
        </div>`
    )
    .join("");

  contentPane().innerHTML = cards || `<p class="muted">Run the pipeline to generate tables.</p>`;

  contentPane()
    .querySelectorAll("button[data-table]")
    .forEach((btn) =>
      btn.addEventListener("click", () => selectTable(btn.dataset.table))
    );
}

function selectTable(name) {
  state.selectedTable = name;
  const textarea = document.getElementById("sql-query");
  textarea.value = `SELECT * FROM ${name} LIMIT 20;`;
  showPipelineStatus(`Ready to query ${name}`);
}

async function executeSqlQuery() {
  const query = document.getElementById("sql-query").value;
  if (!query.trim()) {
    showPipelineStatus("Enter a SQL query", true);
    return;
  }
  const res = await fetch("/api/tables/query", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ query }),
  });
  const payload = await res.json();
  const resultBox = document.getElementById("sql-result");
  if (!res.ok) {
    resultBox.textContent = `Error: ${payload.error}`;
  } else {
    resultBox.textContent = JSON.stringify(payload, null, 2);
  }
}

async function renderPlaceholderView(key) {
  setViewHeader(key);
  contentPane().innerHTML = `<div class="card"><p class="muted">${viewCopy[key].description}</p></div>`;
  detailTitle().textContent = "Inspector";
  detailPane().innerHTML = `<p class="muted">This module will be implemented in the next project phase.</p>`;
}

function showPipelineStatus(message, isError = false) {
  const el = document.getElementById("pipeline-status");
  el.textContent = message;
  el.classList.toggle("text-error", isError);
  el.classList.toggle("text-success", !isError);
}

async function runPipeline() {
  showPipelineStatus("Running ETL pipeline…");
  const res = await fetch("/api/pipeline/run", { method: "POST" });
  if (res.ok) {
    state.tables = [];
    await ensureTablesLoaded();
    showPipelineStatus("Pipeline executed successfully.");
    if (state.currentView === "tables") {
      renderTablesView();
    }
  } else {
    showPipelineStatus("Pipeline execution failed", true);
  }
}

async function handleNavigation(event) {
  const view = event.currentTarget.dataset.view;
  if (!view || state.currentView === view) {
    return;
  }
  state.currentView = view;
  setNavActive(view);
  switch (view) {
    case "credentials":
      await renderCredentialsView();
      break;
    case "apis":
      await renderApisView();
      break;
    case "rules":
      await renderRulesView();
      break;
    case "tables":
      await renderTablesView();
      break;
    case "views":
    case "workflows":
    case "automations":
      await renderPlaceholderView(view);
      break;
    default:
      break;
  }
}

function bootstrap() {
  navButtons().forEach((btn) => btn.addEventListener("click", handleNavigation));
  document.getElementById("run-pipeline").addEventListener("click", runPipeline);
  renderCredentialsView();
}

document.addEventListener("DOMContentLoaded", bootstrap);
