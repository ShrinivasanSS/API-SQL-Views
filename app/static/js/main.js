const state = {
  currentView: "credentials",
  apiPayloads: [],
  selectedApi: null,
  rules: [],
  tables: [],
  selectedTable: null,
  blueprints: null,
  blueprintDetails: {},
  selectedBlueprint: null,
  selectedBlueprintTable: null,
  blueprintDrafts: {},
  aiTasks: [],
  selectedTask: null,
  aiTaskDetails: {},
  aiTaskRuns: {},
  aiWorkflows: [],
  selectedWorkflow: null,
  aiWorkflowDetails: {},
  aiWorkflowRuns: {},
  assistantModes: {
    apis: "code",
    rules: "code",
    tables: "code",
  },
};

function escapeHtml(value) {
  return String(value)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

function renderRowsTable(rows, columns = []) {
  if (!Array.isArray(rows) || !rows.length) {
    return '<p class="muted">No rows returned.</p>';
  }
  const resolvedColumns = columns.length
    ? columns
    : Object.keys(rows[0] || {});
  const header = resolvedColumns
    .map((col) => `<th>${escapeHtml(col)}</th>`)
    .join("");
  const body = rows
    .map((row) => {
      return `<tr>${resolvedColumns
        .map((col) => {
          const value = row[col];
          return `<td>${escapeHtml(
            value === null || value === undefined ? "" : value
          )}</td>`;
        })
        .join("")}</tr>`;
    })
    .join("");
  return `<table><thead><tr>${header}</tr></thead><tbody>${body}</tbody></table>`;
}

function renderSqlStep(step) {
  const title = escapeHtml(step.title || "Step");
  const rowcount = typeof step.rowcount === "number" ? step.rowcount : 0;
  let body = '<p class="muted">No output.</p>';
  if (step.error) {
    body = `<p class="text-error">${escapeHtml(step.error)}</p>`;
  } else if (Array.isArray(step.rows) && step.rows.length) {
    if (typeof step.rows[0] === "object" && step.rows[0] !== null) {
      body = renderRowsTable(step.rows, step.columns || []);
    } else {
      body = `<pre>${escapeHtml(
        JSON.stringify(step.rows, null, 2)
      )}</pre>`;
    }
  }
  return `
    <div class="ai-step-card">
      <div class="ai-step-header">
        <h5>${title}</h5>
        <span class="muted text-xs">${rowcount} row(s)</span>
      </div>
      <div class="ai-step-body">${body}</div>
    </div>
  `;
}

function renderSqlStepList(steps) {
  if (!Array.isArray(steps) || !steps.length) {
    return '<p class="muted">No steps executed.</p>';
  }
  return steps.map((step) => renderSqlStep(step)).join("");
}

function renderOutputBlock(output) {
  if (Array.isArray(output) && output.length) {
    if (typeof output[0] === "object" && output[0] !== null) {
      return renderRowsTable(output);
    }
    return `<pre>${escapeHtml(JSON.stringify(output, null, 2))}</pre>`;
  }
  if (output && typeof output === "object") {
    return `<pre>${escapeHtml(JSON.stringify(output, null, 2))}</pre>`;
  }
  return '<p class="muted">No output.</p>';
}

const viewCopy = {
  credentials: {
    title: "Credentials",
    description: "OAuth credentials loaded from the demo environment.",
  },
  apis: {
    title: "API Catalogue",
    description:
      "Cached API responses grouped by entity type. Refresh to pull the latest payloads.",
  },
  rules: {
    title: "Transformation Rules",
    description:
      "Python snippets that map raw API payloads into queryable observability tables.",
  },
  blueprints: {
    title: "Blueprint Catalogue",
    description:
      "Registered entity blueprints with their declared tables, sample inputs, and rules.",
  },
  tables: {
    title: "Observability Tables",
    description: "SQLite tables generated by the latest ETL pipeline execution.",
  },
  aiTasks: {
    title: "AI Tasks",
    description:
      "System-defined agents that execute SQLite-backed lookups over observability data.",
  },
  aiWorkflows: {
    title: "AI Workflows",
    description:
      "Chain multiple AI tasks to assemble entity investigations and situational summaries.",
  },
  aiAutomations: {
    title: "AI Automations",
    description: "Trigger external systems based on saved queries (work in progress).",
  },
};

const navButtons = () => Array.from(document.querySelectorAll("#nav-pane .nav-item"));
const contentPane = () => document.getElementById("content-pane");
const detailPane = () => document.getElementById("detail-controls");
const detailTitle = () => document.getElementById("detail-title");

function assistantContainer(key) {
  return detailPane().querySelector(`[data-assistant="${key}"]`);
}

function updateAssistantPanels(key) {
  const container = assistantContainer(key);
  if (!container) {
    return;
  }
  const mode = state.assistantModes[key] || "code";
  container
    .querySelectorAll("[data-mode]")
    .forEach((btn) => btn.classList.toggle("active", btn.dataset.mode === mode));
  container
    .querySelectorAll("[data-mode-panel]")
    .forEach((panel) =>
      panel.classList.toggle("hidden", panel.dataset.modePanel !== mode)
    );
}

function initAssistantToggle(key) {
  const container = assistantContainer(key);
  if (!container) {
    return;
  }
  container.querySelectorAll("[data-mode]").forEach((btn) => {
    btn.addEventListener("click", () => {
      state.assistantModes[key] = btn.dataset.mode;
      updateAssistantPanels(key);
    });
  });
  updateAssistantPanels(key);
}

function setAssistantStatus(key, message, isError = false) {
  const container = assistantContainer(key);
  if (!container) {
    return;
  }
  const output = container.querySelector(".assistant-output");
  if (!output) {
    return;
  }
  output.textContent = message;
  const hasMessage = Boolean(message);
  output.classList.toggle("text-error", Boolean(isError && hasMessage));
  output.classList.toggle("text-success", Boolean(!isError && hasMessage));
}

function setAssistantLoading(key, isLoading) {
  const container = assistantContainer(key);
  if (!container) {
    return;
  }
  const button = container.querySelector('[data-assistant-action="ask"]');
  if (button) {
    button.disabled = isLoading;
    button.classList.toggle("loading", isLoading);
  }
}

function setViewHeader(view) {
  const copy = viewCopy[view];
  document.getElementById("view-title").textContent = copy.title;
  document.getElementById("view-description").textContent = copy.description;
}

function setNavActive(view) {
  navButtons().forEach((btn) => {
    if (btn.dataset.view === view) {
      btn.classList.add("active");
    } else {
      btn.classList.remove("active");
    }
  });
}

async function renderCredentialsView() {
  setViewHeader("credentials");
  detailTitle().textContent = "Inspector";
  detailPane().innerHTML =
    "<p class=\"muted\">Credentials are read-only in this demo environment.</p>";

  const res = await fetch("/api/credentials");
  const data = await res.json();

  const rows = Object.entries(data)
    .map(
      ([key, value]) =>
        `<tr><th>${key}</th><td><code>${value}</code></td></tr>`
    )
    .join("");

  contentPane().innerHTML = `
    <div class="card">
      <h3>Demo OAuth Client</h3>
      <table>
        <tbody>${rows}</tbody>
      </table>
    </div>`;
}

async function ensureApiPayloadsLoaded() {
  if (state.apiPayloads.length) {
    return;
  }
  const res = await fetch("/api/apis");
  state.apiPayloads = await res.json();
}

async function renderApisView() {
  setViewHeader("apis");
  detailTitle().textContent = "JQ Explorer";
  detailPane().innerHTML = `
    <div class="right-pane-block" data-assistant="apis">
      <div class="assistant-header">
        <h4>JQ Query Builder</h4>
        <div class="mode-toggle">
          <button type="button" data-mode="code" class="toggle-button">Code</button>
          <button type="button" data-mode="nl" class="toggle-button">Natural Language</button>
        </div>
      </div>
      <div data-mode-panel="code">
        <textarea id="jq-query" placeholder="e.g. .data.monitors[0]"></textarea>
        <div class="flex">
          <button class="primary" id="run-jq">Run</button>
          <button class="secondary" id="copy-jq-result">Copy Result</button>
        </div>
      </div>
      <div data-mode-panel="nl" class="hidden">
        <textarea id="jq-assistant-prompt" placeholder="Describe the JSON fields you want to retrieve"></textarea>
        <div class="flex">
          <button class="primary" id="ask-jq-assistant" data-assistant-action="ask">Generate Query</button>
        </div>
        <div class="assistant-output muted" id="jq-assistant-output">Switch to Natural Language and describe the insight you need.</div>
      </div>
    </div>
    <div class="right-pane-block">
      <h4>Result</h4>
      <div class="result-box" id="jq-result">Select an API payload to query.</div>
    </div>`;

  initAssistantToggle("apis");

  await ensureApiPayloadsLoaded();
  const listItems = state.apiPayloads
    .map(
      (payload) => `
        <div class="list-item" data-id="${payload.id}">
          <div class="space-between">
            <strong>${payload.name}</strong>
            <span class="tag">${payload.category}</span>
          </div>
          <pre class="text-xs">${payload.preview}</pre>
          <button class="secondary text-sm" data-copy="${payload.id}">Copy Response</button>
        </div>`
    )
    .join("");

  contentPane().innerHTML = `<div class="list">${listItems}</div>`;

  contentPane()
    .querySelectorAll(".list-item")
    .forEach((el) => el.addEventListener("click", () => selectApiPayload(el.dataset.id, el)));

  contentPane()
    .querySelectorAll("button[data-copy]")
    .forEach((btn) => btn.addEventListener("click", handleCopyApi));

  document.getElementById("run-jq").addEventListener("click", () => executeJqQuery());
  document.getElementById("copy-jq-result").addEventListener("click", copyJqResult);
  const askAssistant = document.getElementById("ask-jq-assistant");
  if (askAssistant) {
    askAssistant.addEventListener("click", () => askJqAssistant());
  }

  if (state.selectedApi) {
    const el = contentPane().querySelector(`.list-item[data-id="${state.selectedApi}"]`);
    if (el) {
      el.classList.add("selected");
    }
  }
}

async function handleCopyApi(event) {
  event.stopPropagation();
  const id = event.currentTarget.dataset.copy;
  const res = await fetch(`/api/apis/${id}`);
  const data = await res.json();
  await navigator.clipboard.writeText(JSON.stringify(data, null, 2));
  showPipelineStatus("API response copied to clipboard.");
}

async function selectApiPayload(id, element) {
  state.selectedApi = id;
  contentPane()
    .querySelectorAll(".list-item")
    .forEach((el) => el.classList.toggle("selected", el === element));

  const res = await fetch(`/api/apis/${id}`);
  const data = await res.json();
  const pretty = JSON.stringify(data, null, 2);

  element.querySelector("pre").textContent = pretty.slice(0, 240) + (pretty.length > 240 ? "…" : "");

  const detail = document.getElementById("jq-result");
  detail.textContent = pretty;
}

async function executeJqQuery() {
  if (!state.selectedApi) {
    showPipelineStatus("Select an API payload first", true);
    return;
  }

  const query = document.getElementById("jq-query").value.trim();
  if (!query) {
    showPipelineStatus("Enter a JQ query", true);
    return;
  }

  const res = await fetch(`/api/apis/${state.selectedApi}/jq`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ query }),
  });

  const payload = await res.json();
  const detail = document.getElementById("jq-result");
  if (!res.ok) {
    detail.textContent = `Error: ${payload.error}`;
  } else {
    detail.textContent = JSON.stringify(payload.result, null, 2);
  }
}

async function copyJqResult() {
  const detail = document.getElementById("jq-result");
  if (!detail || !detail.textContent.trim()) {
    return;
  }
  await navigator.clipboard.writeText(detail.textContent);
  showPipelineStatus("JQ result copied to clipboard.");
}

async function askJqAssistant() {
  if (!state.selectedApi) {
    setAssistantStatus("apis", "Select an API payload to give the assistant context.", true);
    return;
  }
  const promptInput = document.getElementById("jq-assistant-prompt");
  const prompt = promptInput ? promptInput.value.trim() : "";
  if (!prompt) {
    setAssistantStatus("apis", "Enter a natural language prompt for the assistant.", true);
    if (promptInput) {
      promptInput.focus();
    }
    return;
  }

  setAssistantLoading("apis", true);
  setAssistantStatus("apis", "Generating query suggestion…");

  try {
    const res = await fetch("/api/assistants/apis", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ prompt, payload_id: state.selectedApi }),
    });
    const payload = await res.json();
    if (!res.ok) {
      setAssistantStatus("apis", payload.error || "Assistant request failed", true);
      return;
    }

    const query = payload.query || payload.code || "";
    const explanation = payload.explanation || "";
    const editor = document.getElementById("jq-query");
    if (query && editor) {
      editor.value = query;
      state.assistantModes.apis = "code";
      updateAssistantPanels("apis");
      await executeJqQuery();
    }
    const sections = [];
    if (query) {
      sections.push(`Suggested query:\n${query}`);
    }
    if (explanation) {
      sections.push(explanation);
    }
    setAssistantStatus(
      "apis",
      sections.join("\n\n") || "No query suggestion was generated.",
      !query
    );
  } catch (err) {
    setAssistantStatus("apis", `Assistant error: ${err.message}`, true);
  } finally {
    setAssistantLoading("apis", false);
  }
}

async function ensureRulesLoaded() {
  if (state.rules.length) {
    return;
  }
  const res = await fetch("/api/rules");
  state.rules = await res.json();
}

async function renderRulesView() {
  setViewHeader("rules");
  detailTitle().textContent = "Rule Designer";

  detailPane().innerHTML = `
    <div class="right-pane-block" data-assistant="rules">
      <div class="assistant-header">
        <h4>Rule Editor</h4>
        <div class="mode-toggle">
          <button type="button" data-mode="code" class="toggle-button">Code</button>
          <button type="button" data-mode="nl" class="toggle-button">Natural Language</button>
        </div>
      </div>
      <div data-mode-panel="code">
        <textarea id="rule-preview-content" placeholder="Paste a rule snippet or edit an existing rule."></textarea>
        <input type="text" id="rule-preview-input" placeholder="Relative input path (e.g. sample_inputs/entities/api_current_status.json)" />
        <div class="flex">
          <button class="primary" id="run-rule-preview">Preview</button>
          <button class="secondary" id="save-rule">Save as New Rule</button>
        </div>
      </div>
      <div data-mode-panel="nl" class="hidden">
        <textarea id="rule-assistant-prompt" placeholder="Explain the transformation you need or the columns to produce"></textarea>
        <div class="flex">
          <button class="primary" id="ask-rule-assistant" data-assistant-action="ask">Generate Rule</button>
        </div>
        <div class="assistant-output muted" id="rule-assistant-output">Describe the desired transformation to have a draft Python rule generated.</div>
      </div>
    </div>
    <div class="right-pane-block">
      <h4>Preview Result</h4>
      <div class="result-box" id="rule-preview-result">Select a rule to populate the editor.</div>
    </div>`;

  initAssistantToggle("rules");

  document
    .getElementById("run-rule-preview")
    .addEventListener("click", () => previewRuleTransformation());
  document.getElementById("save-rule").addEventListener("click", () => saveCustomRule());
  const askAssistant = document.getElementById("ask-rule-assistant");
  if (askAssistant) {
    askAssistant.addEventListener("click", () => askRuleAssistant());
  }

  await ensureRulesLoaded();

  const cards = state.rules
    .map(
      (rule) => `
        <div class="card" data-rule="${rule.name}">
          <div class="space-between">
            <div>
              <h3>${rule.title || rule.name}</h3>
              <p class="muted text-sm">${rule.description || ""}</p>
            </div>
            <span class="tag">${rule.table_type || "custom"}</span>
          </div>
          <pre class="text-xs">${rule.content.slice(0, 400)}${rule.content.length > 400 ? "…" : ""}</pre>
          <div class="flex">
            <button class="primary" data-action="preview" data-rule="${rule.name}">Preview</button>
            <button class="secondary" data-action="edit" data-rule="${rule.name}">Load into Editor</button>
          </div>
        </div>`
    )
    .join("");

  contentPane().innerHTML = cards || `<p class="muted">No rules available.</p>`;

  contentPane()
    .querySelectorAll("button[data-action='preview']")
    .forEach((btn) => btn.addEventListener("click", () => previewRule(btn.dataset.rule)));

  contentPane()
    .querySelectorAll("button[data-action='edit']")
    .forEach((btn) => btn.addEventListener("click", () => loadRuleIntoEditor(btn.dataset.rule)));
}

function loadRuleIntoEditor(ruleName) {
  const rule = state.rules.find((r) => r.name === ruleName);
  if (!rule) {
    return;
  }
  document.getElementById("rule-preview-content").value = rule.content;
  document.getElementById("rule-preview-input").value = rule.input || "";
  detailTitle().textContent = `Rule Designer – ${rule.title || rule.name}`;
}

async function previewRule(ruleName) {
  loadRuleIntoEditor(ruleName);
  await previewRuleTransformation(ruleName);
}

async function previewRuleTransformation(ruleName = null) {
  const content = document.getElementById("rule-preview-content").value;
  const inputPath = document.getElementById("rule-preview-input").value;
  const body = { rule_content: content, input_path: inputPath };
  if (ruleName) {
    body.rule_name = ruleName;
  }

  const res = await fetch("/api/rules/preview", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
  const payload = await res.json();

  const resultBox = document.getElementById("rule-preview-result");
  if (!res.ok) {
    resultBox.textContent = `Error: ${payload.error}`;
  } else {
    resultBox.textContent = JSON.stringify(payload, null, 2);
  }
}

async function saveCustomRule() {
  const name = prompt("New rule name (alphanumeric & underscores)");
  if (!name) {
    return;
  }
  const content = document.getElementById("rule-preview-content").value;
  if (!content.trim()) {
    showPipelineStatus("Rule content is empty", true);
    return;
  }

  const res = await fetch("/api/rules", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ name, content }),
  });
  const payload = await res.json();
  if (res.ok) {
    state.rules = [];
    await ensureRulesLoaded();
    renderRulesView();
    showPipelineStatus("Rule saved.");
  } else {
    showPipelineStatus(payload.error || "Unable to save rule", true);
  }
}

async function askRuleAssistant() {
  const promptInput = document.getElementById("rule-assistant-prompt");
  const prompt = promptInput ? promptInput.value.trim() : "";
  if (!prompt) {
    setAssistantStatus("rules", "Tell the assistant what transformation you need.", true);
    if (promptInput) {
      promptInput.focus();
    }
    return;
  }

  const codeEditor = document.getElementById("rule-preview-content");
  const inputField = document.getElementById("rule-preview-input");
  const currentCode = codeEditor ? codeEditor.value : "";
  const inputPath = inputField ? inputField.value : "";

  setAssistantLoading("rules", true);
  setAssistantStatus("rules", "Drafting Python rule…");

  try {
    const res = await fetch("/api/assistants/rules", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ prompt, current_code: currentCode, input_path: inputPath }),
    });
    const payload = await res.json();
    if (!res.ok) {
      setAssistantStatus("rules", payload.error || "Assistant request failed", true);
      return;
    }

    const code = payload.code || payload.query || "";
    const explanation = payload.explanation || "";
    if (code && codeEditor) {
      codeEditor.value = code;
      state.assistantModes.rules = "code";
      updateAssistantPanels("rules");
      await previewRuleTransformation();
    }
    const sections = [];
    if (code) {
      sections.push("Rule updated in the editor.");
    }
    if (explanation) {
      sections.push(explanation);
    }
    setAssistantStatus(
      "rules",
      sections.join("\n\n") || "No code suggestion was generated.",
      !code
    );
  } catch (err) {
    setAssistantStatus("rules", `Assistant error: ${err.message}`, true);
  } finally {
    setAssistantLoading("rules", false);
  }
}

async function ensureTablesLoaded() {
  const res = await fetch("/api/tables");
  state.tables = await res.json();
}

async function renderTablesView() {
  setViewHeader("tables");
  detailTitle().textContent = "SQL Query";
  detailPane().innerHTML = `
    <div class="right-pane-block" data-assistant="tables">
      <div class="assistant-header">
        <h4>SQL Workbench</h4>
        <div class="mode-toggle">
          <button type="button" data-mode="code" class="toggle-button">Code</button>
          <button type="button" data-mode="nl" class="toggle-button">Natural Language</button>
        </div>
      </div>
      <div data-mode-panel="code">
        <textarea id="sql-query" placeholder="SELECT * FROM entities LIMIT 10;"></textarea>
        <button class="primary" id="run-sql">Execute</button>
      </div>
      <div data-mode-panel="nl" class="hidden">
        <textarea id="sql-assistant-prompt" placeholder="Ask a question about the tables or describe the dataset you need"></textarea>
        <div class="flex">
          <button class="primary" id="ask-sql-assistant" data-assistant-action="ask">Generate SQL</button>
        </div>
        <div class="assistant-output muted" id="sql-assistant-output">Use natural language to generate SQLite queries and run them automatically.</div>
      </div>
    </div>
    <div class="right-pane-block">
      <h4>Result</h4>
      <div class="result-box" id="sql-result">Choose a table to populate the query editor.</div>
    </div>`;

  initAssistantToggle("tables");

  document.getElementById("run-sql").addEventListener("click", () => executeSqlQuery());
  const askAssistant = document.getElementById("ask-sql-assistant");
  if (askAssistant) {
    askAssistant.addEventListener("click", () => askSqlAssistant());
  }

  await ensureTablesLoaded();

  const cards = state.tables
    .map(
      (table) => `
        <div class="card" data-table="${table.table_name}">
          <div class="space-between">
            <h3>${table.table_name}</h3>
            <span class="tag">${table.rowcount} rows</span>
          </div>
          <p class="muted text-sm">Columns: ${table.columns.join(", ")}</p>
          <pre class="text-xs">${JSON.stringify(table.preview.slice(0, 3), null, 2)}</pre>
          <button class="secondary" data-table="${table.table_name}">View Details</button>
        </div>`
    )
    .join("");

  contentPane().innerHTML = cards || `<p class="muted">Run the pipeline to generate tables.</p>`;

  contentPane()
    .querySelectorAll("button[data-table]")
    .forEach((btn) =>
      btn.addEventListener("click", () => selectTable(btn.dataset.table))
    );
}

function selectTable(name) {
  state.selectedTable = name;
  const textarea = document.getElementById("sql-query");
  textarea.value = `SELECT * FROM ${name} LIMIT 20;`;
  showPipelineStatus(`Ready to query ${name}`);
}

async function executeSqlQuery() {
  const query = document.getElementById("sql-query").value;
  if (!query.trim()) {
    showPipelineStatus("Enter a SQL query", true);
    return;
  }
  const res = await fetch("/api/tables/query", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ query }),
  });
  const payload = await res.json();
  const resultBox = document.getElementById("sql-result");
  if (!res.ok) {
    resultBox.textContent = `Error: ${payload.error}`;
  } else {
    resultBox.textContent = JSON.stringify(payload, null, 2);
  }
}

async function askSqlAssistant() {
  const promptInput = document.getElementById("sql-assistant-prompt");
  const prompt = promptInput ? promptInput.value.trim() : "";
  if (!prompt) {
    setAssistantStatus("tables", "Describe the dataset you want the assistant to query.", true);
    if (promptInput) {
      promptInput.focus();
    }
    return;
  }

  setAssistantLoading("tables", true);
  setAssistantStatus("tables", "Generating SQL…");

  try {
    const res = await fetch("/api/assistants/tables", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ prompt, table_name: state.selectedTable }),
    });
    const payload = await res.json();
    if (!res.ok) {
      setAssistantStatus("tables", payload.error || "Assistant request failed", true);
      return;
    }

    const query = payload.query || payload.code || "";
    const explanation = payload.explanation || "";
    const editor = document.getElementById("sql-query");
    if (query && editor) {
      editor.value = query;
      state.assistantModes.tables = "code";
      updateAssistantPanels("tables");
      await executeSqlQuery();
    }
    const sections = [];
    if (query) {
      sections.push("SQL applied in the editor.");
    }
    if (explanation) {
      sections.push(explanation);
    }
    setAssistantStatus(
      "tables",
      sections.join("\n\n") || "No SQL suggestion was generated.",
      !query
    );
  } catch (err) {
    setAssistantStatus("tables", `Assistant error: ${err.message}`, true);
  } finally {
    setAssistantLoading("tables", false);
  }
}

async function ensureBlueprintsLoaded() {
  if (state.blueprints !== null) {
    return;
  }
  try {
    const res = await fetch("/api/blueprints");
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}`);
    }
    const payload = await res.json();
    state.blueprints = Array.isArray(payload) ? payload : [];
  } catch (err) {
    state.blueprints = [];
    showPipelineStatus(`Unable to load blueprints: ${err.message}`, true);
  }
}

function blueprintCardMarkup(blueprint) {
  const tableBadges = (blueprint.sources || [])
    .slice(0, 6)
    .map(
      (source) =>
        `<li><span class="tag">${escapeHtml(
          source.table_type || source.pillar || ""
        )}</span>${escapeHtml(source.table_name || "")}</li>`
    )
    .join("");
  const overflowCount = Math.max((blueprint.sources || []).length - 6, 0);
  const extraBadge =
    overflowCount > 0
      ? `<li><span class="tag">+${overflowCount}</span>more tables</li>`
      : "";

  return `
    <div class="card blueprint-card" data-blueprint="${escapeHtml(
      blueprint.entity_type
    )}">
      <div class="space-between">
        <div>
          <h3>${escapeHtml(blueprint.entity_type)}</h3>
          <p class="muted text-xs">${escapeHtml(blueprint.path || "")}</p>
        </div>
        <span class="tag">${(blueprint.sources || []).length} tables</span>
      </div>
      <ul class="chip-list">${tableBadges}${extraBadge}</ul>
      <p class="muted text-xs">Click to inspect table schemas and YAML.</p>
    </div>`;
}

async function renderBlueprintsView() {
  setViewHeader("blueprints");
  await ensureBlueprintsLoaded();

  const list = state.blueprints || [];
  if (!list.length) {
    contentPane().innerHTML = `<p class="muted">No blueprints registered yet.</p>`;
  } else {
    const cards = list.map(blueprintCardMarkup).join("");
    contentPane().innerHTML = `<div class="card-column">${cards}</div>`;
  }

  contentPane()
    .querySelectorAll(".card[data-blueprint]")
    .forEach((card) => {
      card.addEventListener("click", () => selectBlueprint(card.dataset.blueprint, card));
      card.classList.toggle(
        "selected",
        card.dataset.blueprint === state.selectedBlueprint
      );
    });

  renderBlueprintDetailPane();
}

async function selectBlueprint(entityType, element) {
  if (!entityType) {
    return;
  }
  state.selectedBlueprint = entityType;
  state.selectedBlueprintTable = null;

  contentPane()
    .querySelectorAll(".card[data-blueprint]")
    .forEach((card) => card.classList.toggle("selected", card === element));

  if (!state.blueprintDetails[entityType]) {
    detailTitle().textContent = `Blueprint · ${entityType}`;
    detailPane().innerHTML = `<p class="muted">Loading blueprint definition…</p>`;
    try {
      const res = await fetch(`/api/blueprints/${encodeURIComponent(entityType)}`);
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}`);
      }
      state.blueprintDetails[entityType] = await res.json();
    } catch (err) {
      showPipelineStatus(`Unable to load blueprint: ${err.message}`, true);
      return;
    }
  }

  renderBlueprintDetailPane();
}

function renderBlueprintDetailValue(value, format = "text") {
  if (value === undefined || value === null) {
    return '<span class="muted">—</span>';
  }

  if (Array.isArray(value)) {
    if (!value.length) {
      return '<span class="muted">—</span>';
    }
    if (format === "chips" || format === "list") {
      const items = value
        .map((item) => `<li>${escapeHtml(item)}</li>`)
        .join("");
      return `<ul class="chip-list">${items}</ul>`;
    }
    return escapeHtml(value.join(", "));
  }

  if (typeof value === "object") {
    if (!Object.keys(value).length) {
      return '<span class="muted">—</span>';
    }
    return `<pre class="text-xs">${escapeHtml(JSON.stringify(value, null, 2))}</pre>`;
  }

  if (format === "code") {
    return `<pre class="text-xs">${escapeHtml(value)}</pre>`;
  }

  const trimmed = String(value).trim();
  if (!trimmed) {
    return '<span class="muted">—</span>';
  }
  return escapeHtml(trimmed);
}

function renderBlueprintDetailPane() {
  if (!state.selectedBlueprint) {
    detailTitle().textContent = "Blueprint Explorer";
    detailPane().innerHTML =
      '<p class="muted">Select a blueprint to inspect its tables and YAML definition.</p>';
    return;
  }

  const details = state.blueprintDetails[state.selectedBlueprint];
  if (!details) {
    detailTitle().textContent = `Blueprint · ${state.selectedBlueprint}`;
    detailPane().innerHTML = '<p class="muted">Loading blueprint definition…</p>';
    return;
  }

  detailTitle().textContent = `Blueprint · ${details.entity_type}`;

  if (!state.selectedBlueprintTable && details.tables.length) {
    state.selectedBlueprintTable = details.tables[0].id;
  }

  const tableOptions = details.tables
    .map(
      (table) =>
        `<option value="${escapeHtml(table.id)}" ${
          table.id === state.selectedBlueprintTable ? "selected" : ""
        }>${escapeHtml(table.table_type || table.type || "")}
        · ${escapeHtml(table.table_name || table.table || "")}</option>`
    )
    .join("");

  const activeTable = details.tables.find(
    (table) => table.id === state.selectedBlueprintTable
  );

  let tableRows =
    '<tr><td colspan="2" class="muted">Select a table to view its configuration.</td></tr>';

  if (activeTable) {
    const parameterSummary = Object.entries(
      (activeTable.source && activeTable.source.parameters) || {}
    ).map(([name, spec]) => {
      if (spec && typeof spec === "object") {
        const parts = [];
        if (spec.source) parts.push(`source=${spec.source}`);
        if (spec.value !== undefined)
          parts.push(`value=${String(spec.value)}`);
        if (spec.default !== undefined)
          parts.push(`default=${String(spec.default)}`);
        if (spec.required) parts.push("required");
        if (spec.description) parts.push(String(spec.description));
        const detail = parts.length ? parts.join(" · ") : "—";
        return `${name}: ${detail}`;
      }
      return `${name}: ${String(spec)}`;
    });

    const extractorSummary = (activeTable.extractors || []).map((extractor) =>
      extractor.output_row_name
        ? `${extractor.name} → ${extractor.output_row_name}`
        : extractor.name
    );

    const samplePath =
      (activeTable.sample && activeTable.sample.path) || activeTable.sample_input;

    const rows = [
      { label: "Pillar", value: activeTable.pillar },
      { label: "Table type", value: activeTable.table_type || activeTable.type },
      { label: "Destination table", value: activeTable.table_name || activeTable.table },
      { label: "Description", value: activeTable.description },
      { label: "Upsert keys", value: activeTable.upsert_keys, format: "chips" },
      {
        label: "Extractors",
        value: extractorSummary,
        format: "list",
      },
      {
        label: "Transform rules",
        value: activeTable.transformations,
        format: "list",
      },
      { label: "Sample input", value: samplePath },
      {
        label: "Sample format",
        value: activeTable.sample && activeTable.sample.format,
      },
      {
        label: "Source kind",
        value: activeTable.source && activeTable.source.kind,
      },
      {
        label: "Endpoint",
        value: activeTable.source && activeTable.source.endpoint,
        format: "code",
      },
      {
        label: "HTTP method",
        value: activeTable.source && activeTable.source.method,
      },
      {
        label: "Source config",
        value: activeTable.source && activeTable.source.config,
      },
      {
        label: "Source parameters",
        value: parameterSummary,
        format: "list",
      },
      { label: "Inputs", value: activeTable.inputs },
      { label: "Metadata", value: activeTable.metadata },
    ];

    tableRows = rows
      .map(
        (row) =>
          `<tr><th>${escapeHtml(row.label)}</th><td>${renderBlueprintDetailValue(
            row.value,
            row.format
          )}</td></tr>`
      )
      .join("");
  }

  detailPane().innerHTML = `
    <div class="right-pane-block">
      <h4>Table Configuration</h4>
      <select id="blueprint-table-select">
        ${tableOptions}
      </select>
      <table class="kv-table">
        <tbody>${tableRows}</tbody>
      </table>
    </div>
    <div class="right-pane-block">
      <h4>Blueprint YAML</h4>
      <textarea id="blueprint-editor"></textarea>
      <div class="flex">
        <button class="secondary" id="copy-blueprint-yaml">Copy YAML</button>
        <button class="secondary" id="reset-blueprint-yaml">Reset</button>
      </div>
      <p class="muted text-xs">Edits stay in the browser for preview only.</p>
    </div>
  `;

  const select = document.getElementById("blueprint-table-select");
  if (select) {
    select.addEventListener("change", handleBlueprintTableChange);
  }

  const editor = document.getElementById("blueprint-editor");
  if (editor) {
    const draft = state.blueprintDrafts[state.selectedBlueprint];
    editor.value = draft !== undefined ? draft : details.yaml;
    editor.addEventListener("input", () => {
      state.blueprintDrafts[state.selectedBlueprint] = editor.value;
    });
  }

  const copyButton = document.getElementById("copy-blueprint-yaml");
  if (copyButton && editor) {
    copyButton.addEventListener("click", async () => {
      await copyBlueprintYaml(editor.value);
    });
  }

  const resetButton = document.getElementById("reset-blueprint-yaml");
  if (resetButton && editor) {
    resetButton.addEventListener("click", () => {
      editor.value = details.yaml;
      state.blueprintDrafts[state.selectedBlueprint] = details.yaml;
      showPipelineStatus("Blueprint YAML reset to original.");
    });
  }
}

function handleBlueprintTableChange(event) {
  state.selectedBlueprintTable = event.target.value;
  renderBlueprintDetailPane();
}

async function copyBlueprintYaml(value) {
  if (!value) {
    showPipelineStatus("Blueprint YAML is empty", true);
    return;
  }
  try {
    await navigator.clipboard.writeText(value);
    showPipelineStatus("Blueprint YAML copied to clipboard.");
  } catch (err) {
    showPipelineStatus(`Unable to copy YAML: ${err.message}`, true);
  }
}

async function ensureAiTasksLoaded() {
  if (state.aiTasks.length) {
    return;
  }
  const res = await fetch("/api/ai-tasks");
  if (!res.ok) {
    throw new Error("Unable to load AI tasks");
  }
  const data = await res.json();
  if (Array.isArray(data)) {
    state.aiTasks = data.sort((a, b) =>
      (a.title || a.name || "").localeCompare(b.title || b.name || "")
    );
  } else {
    state.aiTasks = [];
  }
}

async function loadAiTaskDetails(name) {
  if (state.aiTaskDetails[name]) {
    return state.aiTaskDetails[name];
  }
  const res = await fetch(`/api/ai-tasks/${encodeURIComponent(name)}`);
  const payload = await res.json().catch(() => ({}));
  if (!res.ok) {
    throw new Error(payload.error || `Unable to load task ${name}`);
  }
  state.aiTaskDetails[name] = payload;
  return payload;
}

function updateAiTaskSelection() {
  document
    .querySelectorAll("[data-task]")
    .forEach((el) =>
      el.classList.toggle("selected", el.dataset.task === state.selectedTask)
    );
}

async function renderAiTasksView() {
  setViewHeader("aiTasks");
  detailTitle().textContent = "Task Inspector";

  try {
    await ensureAiTasksLoaded();
  } catch (err) {
    contentPane().innerHTML = `
      <div class="card">
        <p class="text-error">${escapeHtml(err.message)}</p>
      </div>`;
    detailPane().innerHTML = `<p class="muted">AI task metadata failed to load.</p>`;
    return;
  }

  if (!state.aiTasks.length) {
    contentPane().innerHTML = `
      <div class="card">
        <p class="muted">No AI tasks are configured.</p>
      </div>`;
    detailPane().innerHTML = `<p class="muted">Add task definitions to seed.yaml to begin.</p>`;
    return;
  }

  if (!state.selectedTask || !state.aiTasks.some((t) => t.name === state.selectedTask)) {
    state.selectedTask = state.aiTasks[0].name;
  }

  const cards = state.aiTasks
    .map(
      (task) => `
        <article class="card ai-card" data-task="${escapeHtml(task.name)}">
          <h3>${escapeHtml(task.title || task.name)}</h3>
          <p class="muted">${escapeHtml(task.description || "")}</p>
        </article>`
    )
    .join("");

  contentPane().innerHTML = `<div class="card-column">${cards}</div>`;
  updateAiTaskSelection();

  document.querySelectorAll("[data-task]").forEach((el) => {
    el.addEventListener("click", async () => {
      state.selectedTask = el.dataset.task;
      updateAiTaskSelection();
      await renderAiTaskDetailPane();
    });
  });

  await renderAiTaskDetailPane();
}

async function renderAiTaskDetailPane() {
  detailTitle().textContent = "Task Inspector";
  const container = detailPane();

  if (!state.selectedTask) {
    container.innerHTML = `<p class="muted">Select a task to inspect inputs and outputs.</p>`;
    return;
  }

  let task;
  try {
    task = await loadAiTaskDetails(state.selectedTask);
  } catch (err) {
    container.innerHTML = `<p class="text-error">${escapeHtml(err.message)}</p>`;
    return;
  }

  const lastRun = state.aiTaskRuns[state.selectedTask];
  const inputHtml = (task.inputs || [])
    .map((field) => {
      const value = lastRun?.inputs?.[field.name] ?? field.default ?? "";
      const placeholder = field.placeholder
        ? ` placeholder="${escapeHtml(field.placeholder)}"`
        : "";
      const description = field.description
        ? `<p class="muted text-xs">${escapeHtml(field.description)}</p>`
        : "";
      return `
        <label class="input-block">
          <span class="input-label">${escapeHtml(field.label || field.name)}</span>
          <textarea class="input-scroll" data-input="${escapeHtml(
            field.name
          )}"${placeholder}>${escapeHtml(value)}</textarea>
          ${description}
        </label>`;
    })
    .join("");

  const instructions = task.instructions || "";

  container.innerHTML = `
    <div class="right-pane-block">
      <h4>${escapeHtml(task.title || task.name)}</h4>
      <p class="muted">${escapeHtml(task.description || "")}</p>
    </div>
    <div class="right-pane-block">
      <h5>Inputs</h5>
      <div class="form-stack">${inputHtml || '<p class="muted">No inputs required.</p>'}</div>
    </div>
    <div class="right-pane-block">
      <h5>Instructions</h5>
      <textarea class="instructions-scroll" data-role="instructions">${escapeHtml(
        instructions
      )}</textarea>
      <p class="muted text-xs">Edits are temporary for experimentation.</p>
    </div>
    <div class="right-pane-actions">
      <button class="primary" id="run-ai-task">Run Task</button>
      <div class="muted text-xs" id="ai-task-status"></div>
    </div>
    <div class="right-pane-block">
      <h5>Execution Steps</h5>
      <div id="ai-task-steps" class="ai-steps-container"></div>
    </div>
    <div class="right-pane-block">
      <h5>Final Output</h5>
      <div id="ai-task-output"></div>
    </div>
  `;

  const runButton = document.getElementById("run-ai-task");
  if (runButton) {
    runButton.addEventListener("click", async () => {
      const formInputs = {};
      container.querySelectorAll("[data-input]").forEach((el) => {
        formInputs[el.dataset.input] = el.value;
      });
      const instructionsValue = container.querySelector(
        '[data-role="instructions"]'
      )?.value;
      await executeAiTaskRun(task.name, formInputs, instructionsValue || "");
    });
  }

  renderAiTaskResults(state.selectedTask);
}

async function executeAiTaskRun(name, inputs, instructions) {
  const statusEl = document.getElementById("ai-task-status");
  const runButton = document.getElementById("run-ai-task");
  if (statusEl) {
    statusEl.textContent = "Running task…";
    statusEl.classList.remove("text-error", "text-success");
  }
  if (runButton) {
    runButton.disabled = true;
    runButton.classList.add("loading");
  }

  try {
    const res = await fetch(`/api/ai-tasks/${encodeURIComponent(name)}/execute`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ inputs, instructions }),
    });
    if (!res.ok) {
      const payload = await res.json().catch(() => ({}));
      throw new Error(payload.error || `Task ${name} failed to execute`);
    }
    const data = await res.json();
    state.aiTaskRuns[name] = { inputs, response: data };
    if (statusEl) {
      statusEl.textContent = "Execution completed.";
      statusEl.classList.add("text-success");
    }
    renderAiTaskResults(name);
  } catch (err) {
    if (statusEl) {
      statusEl.textContent = err.message;
      statusEl.classList.add("text-error");
    }
  } finally {
    if (runButton) {
      runButton.disabled = false;
      runButton.classList.remove("loading");
    }
  }
}

function renderAiTaskResults(name) {
  const stepsContainer = document.getElementById("ai-task-steps");
  const outputContainer = document.getElementById("ai-task-output");
  if (!stepsContainer || !outputContainer) {
    return;
  }
  const run = state.aiTaskRuns[name];
  if (!run || !run.response) {
    stepsContainer.innerHTML = '<p class="muted">Run the task to see execution details.</p>';
    outputContainer.innerHTML = '<p class="muted">No output yet.</p>';
    return;
  }
  stepsContainer.innerHTML = renderSqlStepList(run.response.steps || []);
  outputContainer.innerHTML = renderOutputBlock(run.response.output);
}

async function ensureAiWorkflowsLoaded() {
  if (state.aiWorkflows.length) {
    return;
  }
  const res = await fetch("/api/ai-workflows");
  if (!res.ok) {
    throw new Error("Unable to load AI workflows");
  }
  const data = await res.json();
  if (Array.isArray(data)) {
    state.aiWorkflows = data.sort((a, b) =>
      (a.title || a.name || "").localeCompare(b.title || b.name || "")
    );
  } else {
    state.aiWorkflows = [];
  }
}

async function loadAiWorkflowDetails(name) {
  if (state.aiWorkflowDetails[name]) {
    return state.aiWorkflowDetails[name];
  }
  const res = await fetch(`/api/ai-workflows/${encodeURIComponent(name)}`);
  const payload = await res.json().catch(() => ({}));
  if (!res.ok) {
    throw new Error(payload.error || `Unable to load workflow ${name}`);
  }
  state.aiWorkflowDetails[name] = payload;
  return payload;
}

function updateAiWorkflowSelection() {
  document
    .querySelectorAll("[data-workflow]")
    .forEach((el) =>
      el.classList.toggle(
        "selected",
        el.dataset.workflow === state.selectedWorkflow
      )
    );
}

async function renderAiWorkflowsView() {
  setViewHeader("aiWorkflows");
  detailTitle().textContent = "Workflow Inspector";

  try {
    await ensureAiWorkflowsLoaded();
  } catch (err) {
    contentPane().innerHTML = `
      <div class="card">
        <p class="text-error">${escapeHtml(err.message)}</p>
      </div>`;
    detailPane().innerHTML = `<p class="muted">AI workflow metadata failed to load.</p>`;
    return;
  }

  if (!state.aiWorkflows.length) {
    contentPane().innerHTML = `
      <div class="card">
        <p class="muted">No AI workflows are configured.</p>
      </div>`;
    detailPane().innerHTML = `<p class="muted">Define workflows in seed.yaml to begin.</p>`;
    return;
  }

  if (
    !state.selectedWorkflow ||
    !state.aiWorkflows.some((wf) => wf.name === state.selectedWorkflow)
  ) {
    state.selectedWorkflow = state.aiWorkflows[0].name;
  }

  const cards = state.aiWorkflows
    .map(
      (wf) => `
        <article class="card ai-card" data-workflow="${escapeHtml(wf.name)}">
          <h3>${escapeHtml(wf.title || wf.name)}</h3>
          <p class="muted">${escapeHtml(wf.description || "")}</p>
        </article>`
    )
    .join("");

  contentPane().innerHTML = `<div class="card-column">${cards}</div>`;
  updateAiWorkflowSelection();

  document.querySelectorAll("[data-workflow]").forEach((el) => {
    el.addEventListener("click", async () => {
      state.selectedWorkflow = el.dataset.workflow;
      updateAiWorkflowSelection();
      await renderAiWorkflowDetailPane();
    });
  });

  await renderAiWorkflowDetailPane();
}

async function renderAiWorkflowDetailPane() {
  detailTitle().textContent = "Workflow Inspector";
  const container = detailPane();

  if (!state.selectedWorkflow) {
    container.innerHTML = `<p class="muted">Select a workflow to inspect its configuration.</p>`;
    return;
  }

  let workflow;
  try {
    workflow = await loadAiWorkflowDetails(state.selectedWorkflow);
  } catch (err) {
    container.innerHTML = `<p class="text-error">${escapeHtml(err.message)}</p>`;
    return;
  }

  const lastRun = state.aiWorkflowRuns[state.selectedWorkflow];
  const inputHtml = (workflow.inputs || [])
    .map((field) => {
      const value = lastRun?.inputs?.[field.name] ?? field.default ?? "";
      const placeholder = field.placeholder
        ? ` placeholder="${escapeHtml(field.placeholder)}"`
        : "";
      const description = field.description
        ? `<p class="muted text-xs">${escapeHtml(field.description)}</p>`
        : "";
      return `
        <label class="input-block">
          <span class="input-label">${escapeHtml(field.label || field.name)}</span>
          <textarea class="input-scroll" data-workflow-input="${escapeHtml(
            field.name
          )}"${placeholder}>${escapeHtml(value)}</textarea>
          ${description}
        </label>`;
    })
    .join("");

  container.innerHTML = `
    <div class="right-pane-block">
      <h4>${escapeHtml(workflow.title || workflow.name)}</h4>
      <p class="muted">${escapeHtml(workflow.description || "")}</p>
    </div>
    <div class="right-pane-block">
      <h5>Inputs</h5>
      <div class="form-stack">${inputHtml || '<p class="muted">No inputs required.</p>'}</div>
    </div>
    <div class="right-pane-block">
      <h5>Instructions</h5>
      <textarea class="instructions-scroll" data-workflow-instructions>${escapeHtml(
        workflow.instructions || ""
      )}</textarea>
      <p class="muted text-xs">Edits are temporary for experimentation.</p>
    </div>
    <div class="right-pane-actions">
      <button class="primary" id="run-ai-workflow">Run Workflow</button>
      <div class="muted text-xs" id="ai-workflow-status"></div>
    </div>
    <div class="right-pane-block">
      <h5>Summary</h5>
      <div id="ai-workflow-summary"></div>
    </div>
    <div class="right-pane-block">
      <h5>Task Executions</h5>
      <div id="ai-workflow-steps" class="ai-steps-container"></div>
    </div>
  `;

  const runButton = document.getElementById("run-ai-workflow");
  if (runButton) {
    runButton.addEventListener("click", async () => {
      const inputs = {};
      container.querySelectorAll("[data-workflow-input]").forEach((el) => {
        inputs[el.dataset.workflowInput] = el.value;
      });
      const instructionsValue = container.querySelector(
        "[data-workflow-instructions]"
      )?.value;
      await executeAiWorkflowRun(
        workflow.name,
        inputs,
        instructionsValue || ""
      );
    });
  }

  renderAiWorkflowResults(state.selectedWorkflow);
}

async function executeAiWorkflowRun(name, inputs, instructions) {
  const statusEl = document.getElementById("ai-workflow-status");
  const runButton = document.getElementById("run-ai-workflow");
  if (statusEl) {
    statusEl.textContent = "Running workflow…";
    statusEl.classList.remove("text-error", "text-success");
  }
  if (runButton) {
    runButton.disabled = true;
    runButton.classList.add("loading");
  }

  try {
    const res = await fetch(
      `/api/ai-workflows/${encodeURIComponent(name)}/execute`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ inputs, instructions }),
      }
    );
    if (!res.ok) {
      const payload = await res.json().catch(() => ({}));
      throw new Error(payload.error || `Workflow ${name} failed to execute`);
    }
    const data = await res.json();
    state.aiWorkflowRuns[name] = { inputs, response: data };
    if (statusEl) {
      statusEl.textContent = "Execution completed.";
      statusEl.classList.add("text-success");
    }
    renderAiWorkflowResults(name);
  } catch (err) {
    if (statusEl) {
      statusEl.textContent = err.message;
      statusEl.classList.add("text-error");
    }
  } finally {
    if (runButton) {
      runButton.disabled = false;
      runButton.classList.remove("loading");
    }
  }
}

function renderAiWorkflowResults(name) {
  const summaryContainer = document.getElementById("ai-workflow-summary");
  const stepsContainer = document.getElementById("ai-workflow-steps");
  if (!summaryContainer || !stepsContainer) {
    return;
  }
  const run = state.aiWorkflowRuns[name];
  if (!run || !run.response) {
    summaryContainer.innerHTML = '<p class="muted">Run the workflow to generate a summary.</p>';
    stepsContainer.innerHTML = '<p class="muted">No task executions yet.</p>';
    return;
  }
  summaryContainer.innerHTML = `<pre>${escapeHtml(
    run.response.summary || "No summary produced."
  )}</pre>`;
  const stepCards = (run.response.steps || [])
    .map((step) => {
      const inputs = Object.entries(step.inputs || {})
        .map(([key, value]) => `${escapeHtml(key)}=${escapeHtml(value)}`)
        .join(", ");
      const inputLine = inputs
        ? `<p class="muted text-xs">Inputs: ${inputs}</p>`
        : "";
      return `
        <div class="ai-step-card workflow-step">
          <div class="ai-step-header">
            <h5>${escapeHtml(step.task || "Task")}</h5>
            <span class="muted text-xs">Step ${escapeHtml(
              String(step.step_index || "-")
            )}</span>
          </div>
          ${inputLine}
          <div class="ai-nested-steps">${renderSqlStepList(
            step.steps || []
          )}</div>
        </div>`;
    })
    .join("");
  stepsContainer.innerHTML = stepCards || '<p class="muted">No task executions.</p>';
}

async function renderPlaceholderView(key) {
  setViewHeader(key);
  contentPane().innerHTML = `<div class="card"><p class="muted">${viewCopy[key].description}</p></div>`;
  detailTitle().textContent = "Inspector";
  detailPane().innerHTML = `<p class="muted">This module will be implemented in the next project phase.</p>`;
}

function showPipelineStatus(message, isError = false) {
  const el = document.getElementById("pipeline-status");
  el.textContent = message;
  el.classList.toggle("text-error", isError);
  el.classList.toggle("text-success", !isError);
}

async function runPipeline() {
  showPipelineStatus("Running ETL pipeline…");
  const res = await fetch("/api/pipeline/run", { method: "POST" });
  if (res.ok) {
    state.tables = [];
    await ensureTablesLoaded();
    showPipelineStatus("Pipeline executed successfully.");
    if (state.currentView === "tables") {
      renderTablesView();
    }
  } else {
    showPipelineStatus("Pipeline execution failed", true);
  }
}

async function handleNavigation(event) {
  const view = event.currentTarget.dataset.view;
  if (!view || state.currentView === view) {
    return;
  }
  state.currentView = view;
  setNavActive(view);
  switch (view) {
    case "credentials":
      await renderCredentialsView();
      break;
    case "apis":
      await renderApisView();
      break;
    case "rules":
      await renderRulesView();
      break;
    case "blueprints":
      await renderBlueprintsView();
      break;
    case "tables":
      await renderTablesView();
      break;
    case "aiTasks":
      await renderAiTasksView();
      break;
    case "aiWorkflows":
      await renderAiWorkflowsView();
      break;
    case "aiAutomations":
      await renderPlaceholderView(view);
      break;
    default:
      break;
  }
}

function bootstrap() {
  navButtons().forEach((btn) => btn.addEventListener("click", handleNavigation));
  document.getElementById("run-pipeline").addEventListener("click", runPipeline);
  renderCredentialsView();
}

document.addEventListener("DOMContentLoaded", bootstrap);
